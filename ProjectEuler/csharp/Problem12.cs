using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;
using MathNet.Numerics;
using ProjectEuler;
using ProjectEuler.Resources;

namespace ProjectEuler.csharp
{
    /// <summary>
    /// <see cref="https://projecteuler.net/problem=12"/>
    /// The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
    // 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

    // Let us list the factors of the first seven triangle numbers:
    //triangle number => adds to -> factors
    //1 - 1: 1
    //2 - 3: 1,3
    //3 - 6: 1,2,3,6
    //4 - 10: 1,2,5,10
    //5 - 15: 1,3,5,15
    //6 - 21: 1,3,7,21
    //7 - 28: 1,2,4,7,14,28 - 2^2*7^1 - multiply exponents (adding 1 to each exponent) 3*2 = 6
    // We can see that 28 is the first triangle number to have over five divisors.
    // What is the value of the first triangle number to have over five hundred divisors?

    // Answer is 76576500
    /// </summary>

    public class Problem12 : IProblem
    {
        const int Limit = 500;

        public Answer Solution()
        {
            return new Answer
            {
                Description = SecondAttempt().ToString()
            };
        }

        /// <summary>
        /// Incrementally create the triangle sum numbers and count the divisors for each triangle number until the count is > Limit.
        /// Time: 411 Elapsed milliSeconds, 1127071 ticks.
        /// </summary>
        /// <param name="limit"></param>
        /// <returns></returns>
        private int FirstAttempt(int limit = Limit)
        {
            int triangleSum = 0;
            int triangleNth = 1;
            while (CountDivisors(triangleSum) <= limit)
            {
                triangleSum += triangleNth;
                triangleNth++;
            }
            return triangleSum;
        }

        /// <summary>
        /// Was going to move this out to Util class, but it ran slower so I left it in this class.
        /// When limit is raised to 1000 result local 3912 Elapsed milliSeconds 10729880 ticks vs util - 7319 Elapsed milliSeconds 20071028 ticks
        /// For every divisor up to sqrt(num) there is a corresponding divisor above the square root, except for the sqrt(num) itself.
        /// </summary>
        /// <param name="num"></param>
        /// <returns></returns>
        private int CountDivisors(int num)
        {
            int count = 0;
            var sqrt = Math.Sqrt(num);
            for (int i = 1; i <= sqrt; i++)
            {
                if (num%i == 0)
                    count += 2;
            }
            if (sqrt * sqrt == num)
                count--;

            return count;
        }


        /// <summary>
        /// using prime numbers for divisors speeds up compute by half. Nssty having to guess the number of primes to use though. Among a 10 digit number there is approx 4% primes
        /// Time: 2114 Elapsed milliSeconds, 5797187 ticks
        /// </summary>
        /// <param name="nthTriangle"></param>
        /// <returns></returns>
        private long SecondAttempt(int limit = Limit)
        {
            int triangleSum = 0;
            int triangleNth = 1;
       
            var primes = Util.SieveOfEratosthenes(75000);
            while (PrimeFactorisationNoD(triangleSum, primes) <= limit)
            {
                triangleSum += triangleNth++;
                triangleNth++;
            }
            return triangleSum;
        }


        /// <summary>
        /// 
        /// </summary>
        /// <remarks>>http://www.mathblog.dk/triangle-number-with-more-than-500-divisors</remarks>
        /// <param name="limit"></param>
        /// <param name="primelist"></param>
        /// <returns></returns>
        private long PrimeFactorisationNoD(long limit, IEnumerable<long> primelist)
        {
            if (limit <= 0)
                return 0;

            int nod = 1;
            long remain = limit;

            foreach (long prime in primelist)
            {
                int exponent = 1;
                while (remain%prime == 0)
                {
                    exponent++;
                    remain /= prime;
                }
                nod *= exponent;

                //If there is no remainder, return the count
                if (remain == 1)
                    return nod;
            }
            return nod;
            
        }
    }
}
